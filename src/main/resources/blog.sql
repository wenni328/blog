/*
 Navicat Premium Data Transfer

 Source Server         : Mysql
 Source Server Type    : MySQL
 Source Server Version : 50553
 Source Host           : localhost:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 50553
 File Encoding         : 65001

 Date: 11/06/2018 11:23:39
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '博客id',
  `title` varchar(100) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '标题',
  `author` varchar(30) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '作者',
  `authorId` int(11) NULL DEFAULT NULL COMMENT '作者id',
  `content` mediumtext CHARACTER SET utf8 COLLATE utf8_bin NULL COMMENT '博客内容md',
  `html` mediumtext CHARACTER SET utf8 COLLATE utf8_bin NULL COMMENT '博客内容html',
  `createTime` datetime NULL DEFAULT NULL COMMENT '发表时间',
  `mark` varchar(200) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '标签',
  `sorts` varchar(50) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '分类',
  `picture` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '随机一张图',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 14 CHARACTER SET = utf8 COLLATE = utf8_bin COMMENT = '博客表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES (13, '面试随笔', '谢勇', NULL, '> 2018-05-25，某医疗互联网\n\n 1.自我介绍。\n 2.介绍简历中的项目\n     >扯到一个发布动态的问题，然后直接问微博这样的多线程情况下怎么整，好吧，没考虑到这样的情况。\n \n 3.JVM内存模型\n >**java堆**：Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。\n >\n >**方法区**：方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n >**程序计数器**：程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。\n >**java虚拟机栈**：与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n >**本地方法栈**：本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。\n\n 4.ES2.X支持中文搜索吗，底层数据结构是什么？\n> （没回答出来）es2.x支持中文搜索,底层数据结构是倒序索引，有兴趣的同学们可以去了解下，\n\n 5.HashMap原理，HashMap在多线程下的机制是什么？\n>  [HashMap原理](https://blog.csdn.net/qq_26118603/article/details/79849555)，多线程下的机制？有用到这个吗？多线程下不是不用HashMap吗，面试官让我回去百度。。。\n\n 6.mysql行锁表锁介绍（忘了）\n > 表锁：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低，使用场景：查询为主，少量索引\n > 行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高，场景：有大量按索引条件并发更新少量不同数据，伴随并发查询\n \n 7.ConcurrentHashMap实现原理\n \n\n> CAS无锁算法，分段锁机制\n\n8.CAS算法介绍以及全称\n\n> CAS算法（Compare And Swap）：CAS操作（compare and swap）CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。因为线程不必再等待锁定，只要执行CAS操作就可以，会在预期中完成，所以叫无锁算法。（嘴贱扯了ABA）\n> ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。解决办法：自动记录仪记录下线程操作。面试官：这是怎么记录的，我：奔溃。。。\n\n9.LinkList实现了哪些接口，底层数据结构是什么\n\n> List、AbstractList、Iterable.....接口，底层使用双向环形链表数据结构，问：双向链表的实现方式，我：猝\n\n```\n面试总体感觉不好，每些都懂点儿，但是往深了问，死翘翘，所以去互联网公司面试，这些基础一定要打牢，架构这块可能面试官没这么注重，（要是注重起来那就是底层实现了）。主要就是基础这块：集合框架、锁、多线程\n```\n\n ', '<blockquote>\n<p>2018-05-25，某医疗互联网</p>\n</blockquote>\n<p> 1.自我介绍。<br> 2.介绍简历中的项目</p>\n<pre><code> &gt;扯到一个发布动态的问题，然后直接问微博这样的多线程情况下怎么整，好吧，没考虑到这样的情况。\n</code></pre><p> 3.JVM内存模型</p>\n<blockquote>\n<p><strong>java堆</strong>：Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>\n<p><strong>方法区</strong>：方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br><strong>程序计数器</strong>：程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。<br><strong>java虚拟机栈</strong>：与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br><strong>本地方法栈</strong>：本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p>\n</blockquote>\n<p> 4.ES2.X支持中文搜索吗，底层数据结构是什么？</p>\n<blockquote>\n<p>（没回答出来）es2.x支持中文搜索,底层数据结构是倒序索引，有兴趣的同学们可以去了解下，</p>\n</blockquote>\n<p> 5.HashMap原理，HashMap在多线程下的机制是什么？</p>\n<blockquote>\n<p> <a href=\"https://blog.csdn.net/qq_26118603/article/details/79849555\">HashMap原理</a>，多线程下的机制？有用到这个吗？多线程下不是不用HashMap吗，面试官让我回去百度。。。</p>\n</blockquote>\n<p> 6.mysql行锁表锁介绍（忘了）</p>\n<blockquote>\n<p>表锁：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低，使用场景：查询为主，少量索引<br>行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高，场景：有大量按索引条件并发更新少量不同数据，伴随并发查询</p>\n</blockquote>\n<p> 7.ConcurrentHashMap实现原理</p>\n<blockquote>\n<p>CAS无锁算法，分段锁机制</p>\n</blockquote>\n<p>8.CAS算法介绍以及全称</p>\n<blockquote>\n<p>CAS算法（Compare And Swap）：CAS操作（compare and swap）CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。因为线程不必再等待锁定，只要执行CAS操作就可以，会在预期中完成，所以叫无锁算法。（嘴贱扯了ABA）<br>ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。解决办法：自动记录仪记录下线程操作。面试官：这是怎么记录的，我：奔溃。。。</p>\n</blockquote>\n<p>9.LinkList实现了哪些接口，底层数据结构是什么</p>\n<blockquote>\n<p>List、AbstractList、Iterable…..接口，底层使用双向环形链表数据结构，问：双向链表的实现方式，我：猝</p>\n</blockquote>\n<pre><code>面试总体感觉不好，每些都懂点儿，但是往深了问，死翘翘，所以去互联网公司面试，这些基础一定要打牢，架构这块可能面试官没这么注重，（要是注重起来那就是底层实现了）。主要就是基础这块：集合框架、锁、多线程\n</code></pre>', '2018-06-11 10:49:22', '', ',2,5', 'static/images/24.jpg');
INSERT INTO `blog` VALUES (12, '面试总结（随笔）', '谢勇', NULL, '> 2018-05-25，某医疗互联网\n\n 1.自我介绍。\n 2.介绍简历中的项目\n     >扯到一个发布动态的问题，然后直接问微博这样的多线程情况下怎么整，好吧，没考虑到这样的情况。\n \n 3.JVM内存模型\n >**java堆**：Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。\n >\n >**方法区**：方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n >**程序计数器**：程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。\n >**java虚拟机栈**：与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。\n >**本地方法栈**：本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。\n\n 4.ES2.X支持中文搜索吗，底层数据结构是什么？\n> （没回答出来）es2.x支持中文搜索,底层数据结构是倒序索引，有兴趣的同学们可以去了解下，\n\n 5.HashMap原理，HashMap在多线程下的机制是什么？\n>  [HashMap原理](https://blog.csdn.net/qq_26118603/article/details/79849555)，多线程下的机制？有用到这个吗？多线程下不是不用HashMap吗，面试官让我回去百度。。。\n\n 6.mysql行锁表锁介绍（忘了）\n > 表锁：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低，使用场景：查询为主，少量索引\n > 行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高，场景：有大量按索引条件并发更新少量不同数据，伴随并发查询\n \n 7.ConcurrentHashMap实现原理\n \n\n> CAS无锁算法，分段锁机制\n\n8.CAS算法介绍以及全称\n\n> CAS算法（Compare And Swap）：CAS操作（compare and swap）CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。因为线程不必再等待锁定，只要执行CAS操作就可以，会在预期中完成，所以叫无锁算法。（嘴贱扯了ABA）\n> ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。解决办法：自动记录仪记录下线程操作。面试官：这是怎么记录的，我：奔溃。。。\n\n9.LinkList实现了哪些接口，底层数据结构是什么\n\n> List、AbstractList、Iterable.....接口，底层使用双向环形链表数据结构，问：双向链表的实现方式，我：猝\n\n```\n面试总体感觉不好，每些都懂点儿，但是往深了问，死翘翘，所以去互联网公司面试，这些基础一定要打牢，架构这块可能面试官没这么注重，（要是注重起来那就是底层实现了）。主要就是基础这块：集合框架、锁、多线程\n```\n\n ', '<blockquote>\n<p>2018-05-25，某医疗互联网</p>\n</blockquote>\n<p> 1.自我介绍。<br> 2.介绍简历中的项目</p>\n<pre><code> &gt;扯到一个发布动态的问题，然后直接问微博这样的多线程情况下怎么整，好吧，没考虑到这样的情况。\n</code></pre><p> 3.JVM内存模型</p>\n<blockquote>\n<p><strong>java堆</strong>：Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p>\n<p><strong>方法区</strong>：方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<br><strong>程序计数器</strong>：程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。<br><strong>java虚拟机栈</strong>：与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br><strong>本地方法栈</strong>：本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务。</p>\n</blockquote>\n<p> 4.ES2.X支持中文搜索吗，底层数据结构是什么？</p>\n<blockquote>\n<p>（没回答出来）es2.x支持中文搜索,底层数据结构是倒序索引，有兴趣的同学们可以去了解下，</p>\n</blockquote>\n<p> 5.HashMap原理，HashMap在多线程下的机制是什么？</p>\n<blockquote>\n<p> <a href=\"https://blog.csdn.net/qq_26118603/article/details/79849555\">HashMap原理</a>，多线程下的机制？有用到这个吗？多线程下不是不用HashMap吗，面试官让我回去百度。。。</p>\n</blockquote>\n<p> 6.mysql行锁表锁介绍（忘了）</p>\n<blockquote>\n<p>表锁：开销小，加锁快；不会出现死锁；锁定力度大，发生锁冲突概率高，并发度最低，使用场景：查询为主，少量索引<br>行锁：开销大，加锁慢；会出现死锁；锁定粒度小，发生锁冲突的概率低，并发度高，场景：有大量按索引条件并发更新少量不同数据，伴随并发查询</p>\n</blockquote>\n<p> 7.ConcurrentHashMap实现原理</p>\n<blockquote>\n<p>CAS无锁算法，分段锁机制</p>\n</blockquote>\n<p>8.CAS算法介绍以及全称</p>\n<blockquote>\n<p>CAS算法（Compare And Swap）：CAS操作（compare and swap）CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则返回V。因为线程不必再等待锁定，只要执行CAS操作就可以，会在预期中完成，所以叫无锁算法。（嘴贱扯了ABA）<br>ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。解决办法：自动记录仪记录下线程操作。面试官：这是怎么记录的，我：奔溃。。。</p>\n</blockquote>\n<p>9.LinkList实现了哪些接口，底层数据结构是什么</p>\n<blockquote>\n<p>List、AbstractList、Iterable…..接口，底层使用双向环形链表数据结构，问：双向链表的实现方式，我：猝</p>\n</blockquote>\n<pre><code>面试总体感觉不好，每些都懂点儿，但是往深了问，死翘翘，所以去互联网公司面试，这些基础一定要打牢，架构这块可能面试官没这么注重，（要是注重起来那就是底层实现了）。主要就是基础这块：集合框架、锁、多线程\n</code></pre>', '2018-06-11 10:47:09', '面试', ',2,5', 'static/images/04.jpg');
INSERT INTO `blog` VALUES (11, '适配器模式和装饰者模式', '谢勇', NULL, '### 设计模式\n在面向对象程序设计中，我们把经常会反复的遇到相同的问题，于是我们把这个问题集中抽象出来，用一种通用的方法进行处理，这种通用的方式就是设计模式。\n### 适配器模式\n适配器模式指的是把两个不想连的接口通过某个类连接起来。例子：比如我的小米笔记本电脑没有一个插接网线的接口，这个时候网线和电脑是没法连在一起的，然后我买了一个网线转接口。这时候通过转接口我的网线和电脑就可以连接起来了。\n![这里写图片描述](https://img-blog.csdn.net/20180530140108720?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2MTE4NjAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n### 装饰者模式\n这种本身是一种类型，保持类型接口不变，又能对该类型的其他子类进行加强的能力，就叫装饰者。就好像，我们在一个对象上面增加一种装饰，使得它更好看了，或者功能更强大了。\n\njava io 这个包里有一个类，比较特别，这就是BufferedReader。我们从JDK的源码里，找到它的实现\n\n```\npublic class BufferedReader extends Reader {\n    public BufferedReader(Reader in, int sz) {\n        super(in);\n        if (sz <= 0)\n            throw new IllegalArgumentException(\"Buffer size <= 0\");\n        this.in = in;\n        cb = new char[sz];\n        nextChar = nChars = 0;\n    }\n}\n```\n可以看到，BufferedReader本身就是一个Reader，因为它继承自Reader，同时，还有一个名为 in 的成员变量，也是Reader类型的，然后还开辟了一个数组。实际上，这个数组是为了做缓存的，我们可以一次从 in 这个成员对象中读取多个字符存入 cb 中。当真正调用BufferedReader 的 read 方法的时候，就直接从 cb 中读取了，提高了读取的性能。也就是说BufferedReader所提供的 read 方法经过了 cb 这个缓存的加速，其性能会高于直接从 in 这个对象去读取。这是一种增强普通的 Reader 对象的技术。\n\n注意一点，BufferedReader在对一个Reader的对象做增强的时候，只要求了对象是Reader类型的，并没有要求对象是具体哪个类型。这个in对象可以是SocketReader，也可以是FileReader。', '<h3 id=\"h3-u8BBEu8BA1u6A21u5F0F\"><a name=\"设计模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>设计模式</h3><p>在面向对象程序设计中，我们把经常会反复的遇到相同的问题，于是我们把这个问题集中抽象出来，用一种通用的方法进行处理，这种通用的方式就是设计模式。</p>\n<h3 id=\"h3-u9002u914Du5668u6A21u5F0F\"><a name=\"适配器模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>适配器模式</h3><p>适配器模式指的是把两个不想连的接口通过某个类连接起来。例子：比如我的小米笔记本电脑没有一个插接网线的接口，这个时候网线和电脑是没法连在一起的，然后我买了一个网线转接口。这时候通过转接口我的网线和电脑就可以连接起来了。<br><img src=\"https://img-blog.csdn.net/20180530140108720?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2MTE4NjAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<h3 id=\"h3-u88C5u9970u8005u6A21u5F0F\"><a name=\"装饰者模式\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>装饰者模式</h3><p>这种本身是一种类型，保持类型接口不变，又能对该类型的其他子类进行加强的能力，就叫装饰者。就好像，我们在一个对象上面增加一种装饰，使得它更好看了，或者功能更强大了。</p>\n<p>java io 这个包里有一个类，比较特别，这就是BufferedReader。我们从JDK的源码里，找到它的实现</p>\n<pre><code>public class BufferedReader extends Reader {\n    public BufferedReader(Reader in, int sz) {\n        super(in);\n        if (sz &lt;= 0)\n            throw new IllegalArgumentException(&quot;Buffer size &lt;= 0&quot;);\n        this.in = in;\n        cb = new char[sz];\n        nextChar = nChars = 0;\n    }\n}\n</code></pre><p>可以看到，BufferedReader本身就是一个Reader，因为它继承自Reader，同时，还有一个名为 in 的成员变量，也是Reader类型的，然后还开辟了一个数组。实际上，这个数组是为了做缓存的，我们可以一次从 in 这个成员对象中读取多个字符存入 cb 中。当真正调用BufferedReader 的 read 方法的时候，就直接从 cb 中读取了，提高了读取的性能。也就是说BufferedReader所提供的 read 方法经过了 cb 这个缓存的加速，其性能会高于直接从 in 这个对象去读取。这是一种增强普通的 Reader 对象的技术。</p>\n<p>注意一点，BufferedReader在对一个Reader的对象做增强的时候，只要求了对象是Reader类型的，并没有要求对象是具体哪个类型。这个in对象可以是SocketReader，也可以是FileReader。</p>\n', '2018-06-11 10:33:56', '设计模式 java', ',2,5', 'static/images/23.jpg');
INSERT INTO `blog` VALUES (10, 'springboot-redis', '谢勇', NULL, '###HashMap原理详解（基于jdk1.8）\n> HashMap原理详解，有兴趣的同学可以看下。有错误的地方也希望大佬们能指点下。\n\nHashMap的内部存储是一个数组（bucket），数组的元素Node实现了Map.Entry接口（hash, key, value, next），\n当next非空时候会指向定位相同的另外一个Entry。这里借用大佬一张图\n![这里写图片描述](https://img-blog.csdn.net/20180408131036521?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2MTE4NjAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n###HashMap容量大小、负载因子、阀值\n\n在java api中，HashMap的容量定义为16，而阀值定义为0.75。HashMap容量大小指的是内部存储的这个数组bucket大小，负载因子为0.75。阀值=容量大小*负载因子，当数组中的entity的个数大于阀值的时候，HashMap就会进行扩容，调整为当前大小的两倍同时，初始化容量的大小也是2的次幂（大于等于设定容量的最小次幂），则bucket的大小在扩容前后都将是2的次幂（非常重要，resize时能带来极大便利）。\n\nHashMap源码：\n```\n /**\n  * 初始容量大小 定义为final 必须为2的次幂\n  */\n static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // aka 16\n /**\n  * 加载因子 定义为final\n  */\n  static final float DEFAULT_LOAD_FACTOR = 0.75f;\n\n```\n####为什么HashMap初始容量是16？（深入）\n\nHashMap中有种情况称为Hash碰撞，指的是存数据的时候，两个数据值不一样，但是hashcode一样，也就是说一个hashcode对应多个值，（面试一题：hashcode相同值不一定相同，值相同hashcode一定相同），所以在HashMap中为了尽量减少hash值得碰撞，需要实现一个尽量\n均匀分布的hash函数。\n\n> 为什么HashMap初始容量是16？\n公式jdk中的：index = e.hash & (newCap - 1)\n\n举例证明：假设是容量16\nkey | 十进制 | 二进制|与初始量16的与（&）操作\n:----------- | :-----------: | -----------:\n16（初始量）         | 15| 1111\nadmin| 171271319| 1010001101010110010010010111|0111\nhello| 288970072| 10001001110010101010101011000|1000\nname| 6071694| 10111001010010110001110|1110\n\n假设是容量10\nkey | 十进制 | 二进制|与初始量16的与（&）操作\n:----------- | :-----------: | -----------:\n10（初始量）         | 9| 1001\nadmin| 171271319| 1010001101010110010010010111|0001\nhello| 288970072| 10001001110010101010101011000|1000\nname| 6071694| 10111001010010110001110|1000\n\n怎么样，同学们看出规律来了没，十进制结果碰撞太容易了。最终原因还是因为二进制的与运算，同位1可为1，否则为0。初始容量为16时候，十进制为（16-1=15）1111。相当于几乎只与key.hash有关了（当然除非是两个key的hash后四位都是1111就会产生碰撞了）。其他的也是试试，比如初始量为8,5,12什么的都可以，但是16才最能减少碰撞了。当然低4位也是比较容易发生碰撞的，所以设计者在hash方法上做了手脚（看下面hash方法，在hash上使用了异或一下，节省了开支，又步骤简单）\n\n###HashMap的hash方法(混乱函数)\n```\n static final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);\n    }\n```\n这里jdk为了保证良好的hashcode，对key进一步使用了hashcode方法。使用的是自身的高16位与低16位进行异或，进步一散列hash,其中hashcode是Object的方法，注意这里的多态使用。\nkey | 调用hashcode() |**然后**位移16 |hash值|下标（公式）计算|下标十进制\n:----------- | :-----------: | -----------:\nadmin| 101100001100000001101001111|10110000110|101100001100000011011001001|1001|9\n图解：这图画的我好尴尬啊\n![这里写图片描述](https://img-blog.csdn.net/20180408113834581?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2MTE4NjAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n\n###HashMap的put、get\n\n> put方法引发的思考\n\n 1. 在一个长度为16的数组中，元素到底是存储在哪里的呢。其实这个问题在hash方法里面我就解说了，获取了hash值之后，会与数组的长度作一个与操作，最终获取到的是一个低四位的二进制，如上图中的1001，最终下标就是9.\n 2. 哪怕经过了hash异或，还是有可能会发生hash碰撞，那么HashMap是怎么处理这些hash值相同的元素的呢。一张比较丑的图来解释下hashmap内部的构造\n ![这里写图片描述](https://img-blog.csdn.net/20180408134638725?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2MTE4NjAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)\n 以我们的角度来看，这个Map横向是数组形式，纵向是一条条链表形式，存储位置算法是根据hash(key)%len得到的，比如hash（key）=30, 30%16=14，存的位置为14下标。hash（key）=14,14%16=14，这个时候之前的30就会被挤下去，而14元素会取代链表第一个位置。30就变成了存储在第二个位置。这个就很好的解释了Node元素里面的next，指向了定位相同的一个Entity。当链表长度大于8 的时候，链表就会转换成红黑树结构（这其实是为了优化速度），时间复杂度变成了log(n)。\n **PUT方法源码解读**\n \n\n```\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node<K,V>[] tab; Node<K,V> p; int n, i;\n        //table数组为空，重新分配内存空间\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n            //tab[数组下标]的值为null的时候，这个值重新初始化Node节点，并放置在这个位置\n        if ((p = tab[i = (n - 1) & hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {//如果这个坐标数组有数据的话\n            Node<K,V> e; K k;\n            //如果key相同 key的hash也相同 两个节点相等\n            if (p.hash == hash &&\n                ((k = p.key) == key || (key != null && key.equals(k))))\n                e = p;\n                //如果该节点是代表红黑树的节点，调用红黑树的插值方法\n            else if (p instanceof TreeNode)\n                e = ((TreeNode<K,V>)p).putTreeVal(this, tab, hash, key, value);\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        //当单个桶（bucket）>=（8-1=7）的时候 调用treeifyBin转换为红黑树结构\n                        if (binCount >= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size > threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n```\n**get方法解读**\n\n```\n final Node<K,V> getNode(int hash, Object key) {\n        Node<K,V>[] tab; Node<K,V> first, e; int n; K k;\n        if ((tab = table) != null && (n = tab.length) > 0 &&\n            (first = tab[(n - 1) & hash]) != null) {\n                // 判断第一个节点是不是就是需要的\n            if (first.hash == hash && // always check first node\n                ((k = first.key) == key || (key != null && key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                 // 判断是否是红黑树\n                if (first instanceof TreeNode)\n                    return ((TreeNode<K,V>)first).getTreeNode(hash, key);\n                do {\n                     // 链表遍历\n                    if (e.hash == hash &&\n                        ((k = e.key) == key || (key != null && key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n\n```\n## 电面一题：HashMap在多线程中是采取了什么机制？ ##\n楼主想了好久没答上来，有知道得同行可以在评论区留言\n\n', '<h3 id=\"h3-hashmap-jdk1-8-\"><a name=\"HashMap原理详解（基于jdk1.8）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HashMap原理详解（基于jdk1.8）</h3><blockquote>\n<p>HashMap原理详解，有兴趣的同学可以看下。有错误的地方也希望大佬们能指点下。</p>\n</blockquote>\n<p>HashMap的内部存储是一个数组（bucket），数组的元素Node实现了Map.Entry接口（hash, key, value, next），<br>当next非空时候会指向定位相同的另外一个Entry。这里借用大佬一张图<br><img src=\"https://img-blog.csdn.net/20180408131036521?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2MTE4NjAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<h3 id=\"h3-hashmap-\"><a name=\"HashMap容量大小、负载因子、阀值\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HashMap容量大小、负载因子、阀值</h3><p>在java api中，HashMap的容量定义为16，而阀值定义为0.75。HashMap容量大小指的是内部存储的这个数组bucket大小，负载因子为0.75。阀值=容量大小*负载因子，当数组中的entity的个数大于阀值的时候，HashMap就会进行扩容，调整为当前大小的两倍同时，初始化容量的大小也是2的次幂（大于等于设定容量的最小次幂），则bucket的大小在扩容前后都将是2的次幂（非常重要，resize时能带来极大便利）。</p>\n<p>HashMap源码：</p>\n<pre><code> /**\n  * 初始容量大小 定义为final 必须为2的次幂\n  */\n static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16\n /**\n  * 加载因子 定义为final\n  */\n  static final float DEFAULT_LOAD_FACTOR = 0.75f;\n</code></pre><h4 id=\"h4--hashmap-16-\"><a name=\"为什么HashMap初始容量是16？（深入）\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>为什么HashMap初始容量是16？（深入）</h4><p>HashMap中有种情况称为Hash碰撞，指的是存数据的时候，两个数据值不一样，但是hashcode一样，也就是说一个hashcode对应多个值，（面试一题：hashcode相同值不一定相同，值相同hashcode一定相同），所以在HashMap中为了尽量减少hash值得碰撞，需要实现一个尽量<br>均匀分布的hash函数。</p>\n<blockquote>\n<p>为什么HashMap初始容量是16？<br>公式jdk中的：index = e.hash &amp; (newCap - 1)</p>\n</blockquote>\n<p>举例证明：假设是容量16<br>key | 十进制 | 二进制|与初始量16的与（&amp;）操作<br>:—————- | :—————-: | —————-:<br>16（初始量）         | 15| 1111<br>admin| 171271319| 1010001101010110010010010111|0111<br>hello| 288970072| 10001001110010101010101011000|1000<br>name| 6071694| 10111001010010110001110|1110</p>\n<p>假设是容量10<br>key | 十进制 | 二进制|与初始量16的与（&amp;）操作<br>:—————- | :—————-: | —————-:<br>10（初始量）         | 9| 1001<br>admin| 171271319| 1010001101010110010010010111|0001<br>hello| 288970072| 10001001110010101010101011000|1000<br>name| 6071694| 10111001010010110001110|1000</p>\n<p>怎么样，同学们看出规律来了没，十进制结果碰撞太容易了。最终原因还是因为二进制的与运算，同位1可为1，否则为0。初始容量为16时候，十进制为（16-1=15）1111。相当于几乎只与key.hash有关了（当然除非是两个key的hash后四位都是1111就会产生碰撞了）。其他的也是试试，比如初始量为8,5,12什么的都可以，但是16才最能减少碰撞了。当然低4位也是比较容易发生碰撞的，所以设计者在hash方法上做了手脚（看下面hash方法，在hash上使用了异或一下，节省了开支，又步骤简单）</p>\n<h3 id=\"h3-hashmap-hash-\"><a name=\"HashMap的hash方法(混乱函数)\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HashMap的hash方法(混乱函数)</h3><pre><code> static final int hash(Object key) {\n        int h;\n        return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);\n    }\n</code></pre><p>这里jdk为了保证良好的hashcode，对key进一步使用了hashcode方法。使用的是自身的高16位与低16位进行异或，进步一散列hash,其中hashcode是Object的方法，注意这里的多态使用。<br>key | 调用hashcode() |<strong>然后</strong>位移16 |hash值|下标（公式）计算|下标十进制<br>:—————- | :—————-: | —————-:<br>admin| 101100001100000001101001111|10110000110|101100001100000011011001001|1001|9<br>图解：这图画的我好尴尬啊<br><img src=\"https://img-blog.csdn.net/20180408113834581?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2MTE4NjAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"></p>\n<h3 id=\"h3-hashmap-put-get\"><a name=\"HashMap的put、get\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>HashMap的put、get</h3><blockquote>\n<p>put方法引发的思考</p>\n</blockquote>\n<ol>\n<li>在一个长度为16的数组中，元素到底是存储在哪里的呢。其实这个问题在hash方法里面我就解说了，获取了hash值之后，会与数组的长度作一个与操作，最终获取到的是一个低四位的二进制，如上图中的1001，最终下标就是9.</li><li>哪怕经过了hash异或，还是有可能会发生hash碰撞，那么HashMap是怎么处理这些hash值相同的元素的呢。一张比较丑的图来解释下hashmap内部的构造<br><img src=\"https://img-blog.csdn.net/20180408134638725?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI2MTE4NjAz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70\" alt=\"这里写图片描述\"><br>以我们的角度来看，这个Map横向是数组形式，纵向是一条条链表形式，存储位置算法是根据hash(key)%len得到的，比如hash（key）=30, 30%16=14，存的位置为14下标。hash（key）=14,14%16=14，这个时候之前的30就会被挤下去，而14元素会取代链表第一个位置。30就变成了存储在第二个位置。这个就很好的解释了Node元素里面的next，指向了定位相同的一个Entity。当链表长度大于8 的时候，链表就会转换成红黑树结构（这其实是为了优化速度），时间复杂度变成了log(n)。<br><strong>PUT方法源码解读</strong></li></ol>\n<pre><code>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,\n                   boolean evict) {\n        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n        //table数组为空，重新分配内存空间\n        if ((tab = table) == null || (n = tab.length) == 0)\n            n = (tab = resize()).length;\n            //tab[数组下标]的值为null的时候，这个值重新初始化Node节点，并放置在这个位置\n        if ((p = tab[i = (n - 1) &amp; hash]) == null)\n            tab[i] = newNode(hash, key, value, null);\n        else {//如果这个坐标数组有数据的话\n            Node&lt;K,V&gt; e; K k;\n            //如果key相同 key的hash也相同 两个节点相等\n            if (p.hash == hash &amp;&amp;\n                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))\n                e = p;\n                //如果该节点是代表红黑树的节点，调用红黑树的插值方法\n            else if (p instanceof TreeNode)\n                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n            else {\n                for (int binCount = 0; ; ++binCount) {\n                    if ((e = p.next) == null) {\n                        p.next = newNode(hash, key, value, null);\n                        //当单个桶（bucket）&gt;=（8-1=7）的时候 调用treeifyBin转换为红黑树结构\n                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st\n                            treeifyBin(tab, hash);\n                        break;\n                    }\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        break;\n                    p = e;\n                }\n            }\n            if (e != null) { // existing mapping for key\n                V oldValue = e.value;\n                if (!onlyIfAbsent || oldValue == null)\n                    e.value = value;\n                afterNodeAccess(e);\n                return oldValue;\n            }\n        }\n        ++modCount;\n        if (++size &gt; threshold)\n            resize();\n        afterNodeInsertion(evict);\n        return null;\n    }\n</code></pre><p><strong>get方法解读</strong></p>\n<pre><code> final Node&lt;K,V&gt; getNode(int hash, Object key) {\n        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;\n        if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;\n            (first = tab[(n - 1) &amp; hash]) != null) {\n                // 判断第一个节点是不是就是需要的\n            if (first.hash == hash &amp;&amp; // always check first node\n                ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))\n                return first;\n            if ((e = first.next) != null) {\n                 // 判断是否是红黑树\n                if (first instanceof TreeNode)\n                    return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);\n                do {\n                     // 链表遍历\n                    if (e.hash == hash &amp;&amp;\n                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))\n                        return e;\n                } while ((e = e.next) != null);\n            }\n        }\n        return null;\n    }\n</code></pre><h2 id=\"h2--hashmap-\"><a name=\"电面一题：HashMap在多线程中是采取了什么机制？\" class=\"reference-link\"></a><span class=\"header-link octicon octicon-link\"></span>电面一题：HashMap在多线程中是采取了什么机制？</h2><p>楼主想了好久没答上来，有知道得同行可以在评论区留言</p>\n', '2018-06-11 10:27:22', 'java HashMap', ',2,5', 'static/images/25.jpg');

-- ----------------------------
-- Table structure for markword
-- ----------------------------
DROP TABLE IF EXISTS `markword`;
CREATE TABLE `markword`  (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(30) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '博客标签名',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_bin COMMENT = '博客标签表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Table structure for types
-- ----------------------------
DROP TABLE IF EXISTS `types`;
CREATE TABLE `types`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '类型id',
  `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '类型名称',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 8 CHARACTER SET = utf8 COLLATE = utf8_bin COMMENT = '博客类型' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of types
-- ----------------------------
INSERT INTO `types` VALUES (1, 'springboot');
INSERT INTO `types` VALUES (2, '日记');
INSERT INTO `types` VALUES (3, 'springcloud');
INSERT INTO `types` VALUES (4, 'layui');
INSERT INTO `types` VALUES (5, 'java基础');
INSERT INTO `types` VALUES (6, 'vue2');
INSERT INTO `types` VALUES (7, 'java核心');

-- ----------------------------
-- Table structure for users
-- ----------------------------
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users`  (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户id',
  `username` varchar(30) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '用户名称',
  `password` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '用户密码',
  `motto` varchar(255) CHARACTER SET utf8 COLLATE utf8_bin NULL DEFAULT NULL COMMENT '格言',
  `createTime` datetime NULL DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = MyISAM AUTO_INCREMENT = 1 CHARACTER SET = utf8 COLLATE = utf8_bin COMMENT = '用户表' ROW_FORMAT = Dynamic;

SET FOREIGN_KEY_CHECKS = 1;
